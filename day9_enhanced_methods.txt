    def generate_action_plan(
        self,
        domain: Dict,
        quality: Dict,
        analytics: Dict,
        profile: Dict
    ) -> str:
        """
        'Your Path Forward' - Action plan (Day 9 ✅ ENHANCED)
        
        Give users a sequenced, actionable plan based on their data issues.
        Now with domain-aware recommendations and smart sequencing.
        """
        # Get pain points from quality metrics
        pain_points = self._extract_pain_points_from_quality(quality, profile)
        
        # Get action steps (AI-enhanced if available)
        if self.ai_engine and pain_points:
            try:
                steps = self.ai_engine.generate_action_plan(
                    domain=domain,
                    pain_points=pain_points,
                    profile=profile,
                    analytics=analytics
                )
            except Exception as e:
                print(f'⚠️  AI action plan failed, using enhanced fallback: {e}')
                steps = self._enhanced_action_plan(domain, quality, profile, pain_points)
        else:
            # Use enhanced fallback with domain awareness
            steps = self._enhanced_action_plan(domain, quality, profile, pain_points)
        
        # Get intro based on severity
        intro = self._get_action_intro(pain_points)
        
        steps_html = '\n'.join([f'<li>{step}</li>' for step in steps])
        
        return f'''
        <div class='narrative-section action-plan'>
            <h3>🎯 Your Path Forward</h3>
            <p>{intro}</p>
            <ol class='action-steps'>
                {steps_html}
            </ol>
        </div>
        '''
    
    def _extract_pain_points_from_quality(self, quality: Dict, profile: Dict) -> List[Dict]:
        '''Extract pain points from quality metrics'''
        pain_points = []
        
        missing_pct = quality.get('missing_pct', 0)
        duplicates = quality.get('duplicates', 0)
        
        if missing_pct > 5:
            severity = 'high' if missing_pct > 20 else 'medium'
            pain_points.append({
                'severity': severity,
                'issue': f'{missing_pct:.1f}% missing data',
                'fix': f'Fill or flag {missing_pct:.1f}% missing values'
            })
        
        if duplicates > 0:
            severity = 'high' if duplicates > 100 else 'medium'
            pain_points.append({
                'severity': severity,
                'issue': f'{duplicates} duplicate rows',
                'fix': f'Remove {duplicates} duplicate rows after verification'
            })
        
        return pain_points
    
    def _get_action_intro(self, pain_points: List[Dict]) -> str:
        '''Get contextual intro based on pain severity'''
        if not pain_points:
            return 'Your data looks clean! Here's how to get the most value from it:'
        
        high_severity = sum(1 for p in pain_points if p.get('severity') in ['critical', 'high'])
        
        if high_severity >= 3:
            return '⚠️ <strong>Your data needs immediate attention.</strong> Follow these steps in order:'
        elif high_severity > 0:
            return 'Here's a prioritized plan to address your data quality issues:'
        else:
            return 'Your data quality is good overall. Here are recommended improvements:'
    
    def _enhanced_action_plan(
        self,
        domain: Dict,
        quality: Dict,
        profile: Dict,
        pain_points: List[Dict]
    ) -> List[str]:
        '''Enhanced action plan with domain awareness and logical sequencing'''
        steps = []
        domain_type = domain.get('type', 'unknown')
        
        # PHASE 1: CLEAN (high severity issues first)
        critical_points = [p for p in pain_points if p.get('severity') in ['critical', 'high']]
        for point in sorted(critical_points, key=lambda x: 0 if x.get('severity') == 'critical' else 1):
            fix = point.get('fix', '')
            steps.append(f'<strong>Clean:</strong> {fix}')
        
        # PHASE 2: VALIDATE (domain-specific)
        validation = self._get_domain_validation(domain_type)
        if validation:
            steps.append(f'<strong>Validate:</strong> {validation}')
        
        # PHASE 3: ANALYZE (domain-specific)
        analysis = self._get_domain_analysis(domain_type)
        if analysis:
            steps.append(f'<strong>Analyze:</strong> {analysis}')
        
        # PHASE 4: VISUALIZE
        viz = self._get_domain_visualization(domain_type)
        if viz:
            steps.append(f'<strong>Visualize:</strong> {viz}')
        
        # Fallback to generic if no steps
        if not steps:
            steps = [
                '<strong>Profile:</strong> Review column types and statistics',
                '<strong>Clean:</strong> Address any data quality issues',
                '<strong>Analyze:</strong> Calculate key metrics and trends',
                '<strong>Visualize:</strong> Create charts to communicate insights'
            ]
        
        return steps
    
    def _get_domain_validation(self, domain_type: str) -> str:
        '''Get domain-specific validation checks'''
        validations = {
            'sales': 'Verify all transactions have positive amounts and valid dates',
            'finance': 'Ensure debits and credits balance correctly',
            'ecommerce': 'Confirm order statuses are valid and payment amounts match totals',
            'marketing': 'Validate campaign dates and ensure conversion rates are realistic',
            'healthcare': 'Check patient IDs are unique and dates follow logical sequence',
            'hr': 'Validate employee IDs are unique and hire dates precede termination dates',
            'inventory': 'Ensure stock levels are non-negative and warehouse codes valid',
            'customer': 'Check customer IDs are unique and contact info is properly formatted',
            'web_analytics': 'Verify session IDs are unique and metrics are within realistic bounds',
            'logistics': 'Validate tracking numbers are unique and delivery dates are after ship dates'
        }
        return validations.get(domain_type, 'Check for logical errors and data inconsistencies')
    
    def _get_domain_analysis(self, domain_type: str) -> str:
        '''Get domain-specific analysis recommendations'''
        analyses = {
            'sales': 'Calculate total revenue, average order value, and identify top-selling products',
            'finance': 'Calculate profit margin, ROI, and analyze expense trends',
            'ecommerce': 'Calculate conversion rate, cart abandonment, and customer lifetime value',
            'marketing': 'Calculate ROI per campaign and identify best-performing channels',
            'healthcare': 'Calculate average length of stay and identify common diagnoses',
            'hr': 'Calculate turnover rate and identify departments with highest attrition',
            'inventory': 'Identify slow-moving items and calculate stock turnover ratio',
            'customer': 'Calculate customer lifetime value and churn rate by segment',
            'web_analytics': 'Identify high-bounce pages and analyze user journey funnels',
            'logistics': 'Calculate average delivery time and identify late shipment patterns'
        }
        return analyses.get(domain_type, 'Identify key metrics and trends relevant to your goals')
    
    def _get_domain_visualization(self, domain_type: str) -> str:
        '''Get domain-specific visualization recommendations'''
        visualizations = {
            'sales': 'Build revenue trend over time and product performance comparison',
            'finance': 'Create P&L trend and expense breakdown charts',
            'ecommerce': 'Chart sales funnel and customer acquisition cost trends',
            'marketing': 'Visualize campaign ROI comparison and conversion funnel',
            'healthcare': 'Plot patient flow by department and treatment outcomes',
            'hr': 'Create headcount trend and turnover by department charts',
            'inventory': 'Chart stock levels over time and turnover by product category',
            'customer': 'Visualize customer journey map and satisfaction score trends',
            'web_analytics': 'Build traffic trend and page performance heatmaps',
            'logistics': 'Chart delivery time distribution and on-time percentage trends'
        }
        return visualizations.get(domain_type, 'Create time series and distribution charts for key metrics')
    
    def _fallback_action_plan(self, pain_points: List[Dict]) -> List[str]:
        '''OLD - kept for compatibility but not used anymore'''
        if not pain_points:
            return ['1. Proceed with analysis', '2. Build visualizations', '3. Extract insights']
        steps = []
        for i, point in enumerate(pain_points[:5], 1):
            fix = point.get('fix', 'Address: ' + point.get('issue', 'Unknown'))
            steps.append(f'{i}. {fix}')
        return steps
